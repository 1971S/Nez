(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{108:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var o=n(0),r=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),b=o,h=u["".concat(a,".").concat(b)]||u[b]||d[b]||i;return n?r.a.createElement(h,s(s({ref:t},p),{},{components:n})):r.a.createElement(h,s({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var p=2;p<i;p++)a[p]=n[p];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},158:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/inspector-6cc1b0ef39f061186ac9d6e7cc769eff.png"},94:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return a})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return p}));var o=n(3),r=(n(0),n(108));const i={id:"RuntimeInspector",title:"Runtime Inspector"},a={unversionedId:"features/RuntimeInspector",id:"features/RuntimeInspector",isDocsHomePage:!1,title:"Runtime Inspector",description:"Nez includes some really handy runtime Entity and PostProcessor inspection facilities. You can access the inspector by opening the debug console (via the tilde key) and then using the inspect command. Out of the box the inspector can inspect the following types: int, float, string, bool, enum, Color, some structs, Effect subclasses and Transform. When you use the inspect command you can either pass in an Entity name or pp, the latter will inspect all the PostProcessors in the Scene.",source:"@site/docs\\features\\RuntimeInspector.md",slug:"/features/RuntimeInspector",permalink:"/Nez/docs/features/RuntimeInspector",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/RuntimeInspector.md",version:"current",sidebar:"someSidebar",previous:{title:"Tweening",permalink:"/Nez/docs/features/Tweening"},next:{title:"Rendering",permalink:"/Nez/docs/features/Graphics/Rendering"}},s=[{value:"Exposing Properties and Fields in the Inspector",id:"exposing-properties-and-fields-in-the-inspector",children:[]},{value:"Exposing Methods in the Inspector",id:"exposing-methods-in-the-inspector",children:[]},{value:"Tooltips",id:"tooltips",children:[]},{value:"Extending the Inspector",id:"extending-the-inspector",children:[]}],c={toc:s};function p({components:e,...t}){return Object(r.b)("wrapper",Object(o.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Nez includes some really handy runtime Entity and PostProcessor inspection facilities. You can access the inspector by opening the debug console (via the tilde key) and then using the ",Object(r.b)("inlineCode",{parentName:"p"},"inspect")," command. Out of the box the inspector can inspect the following types: int, float, string, bool, enum, Color, some structs, Effect subclasses and Transform. When you use the ",Object(r.b)("inlineCode",{parentName:"p"},"inspect")," command you can either pass in an Entity name or ",Object(r.b)("inlineCode",{parentName:"p"},"pp"),", the latter will inspect all the PostProcessors in the Scene."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Inspector inspecting the player object from the Nez.Samples repo",src:n(158).default})),Object(r.b)("h2",{id:"exposing-properties-and-fields-in-the-inspector"},"Exposing Properties and Fields in the Inspector"),Object(r.b)("p",null,"By default, the inspector will display any public properties/fields that are of a supported type. It will also check Materials for non-null Effects and it will display any valid properties from the Effect. The inspector can also display private fields/properties by just adding the ",Object(r.b)("inlineCode",{parentName:"p"},"Inspectable")," attribute:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},"[Inspectable]\nstring myPrivateField;\n")),Object(r.b)("p",null,"Int and float fields/properties can optionally be displayed with a slider by adding the ",Object(r.b)("inlineCode",{parentName:"p"},"Range")," attribute. Note that you do not have to add both the ",Object(r.b)("inlineCode",{parentName:"p"},"Inspectable")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Range")," attributes for private fields/properties. Just the ",Object(r.b)("inlineCode",{parentName:"p"},"Range")," attribute is enough to let the inspector know you want it displayed."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},"[Range( 0.1f, 100 )]\nfloat groundAccel;\n\n// the third, optional parameter lets you specify the sliders step value\n[Range( 0.1f, 100, 5 )]\nfloat airAccel;\n")),Object(r.b)("h2",{id:"exposing-methods-in-the-inspector"},"Exposing Methods in the Inspector"),Object(r.b)("p",null,"The inspector also has the ability to expose a button to call methods. Methods must have 0 to 1 parameters and if they have a parameter it must be of type int, float, bool or string. To expose a method in the inspector add the ",Object(r.b)("inlineCode",{parentName:"p"},"InspectorCallable")," attribute to the method. An example is below:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},"[InspectorCallable]\npublic void DoSomething()\n{}\n\n\n[InspectorCallable]\npublic void DoSomethingWithParameter( bool isDone )\n{}\n\n\n[InspectorCallable]\npublic void ThisWontWorkBecauseItHasTwoParameters( bool isDone, int stuff )\n{}\n")),Object(r.b)("h2",{id:"tooltips"},"Tooltips"),Object(r.b)("p",null,"You can add tooltips to the inspector via the ",Object(r.b)("inlineCode",{parentName:"p"},"TooltipAttribute"),". Tooltips will appear when you hover over the label for an inspected field."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},'[Tooltip( "Acceleration when on the ground" )]\nfloat groundAccel = 1.0f;\n')),Object(r.b)("h2",{id:"extending-the-inspector"},"Extending the Inspector"),Object(r.b)("p",null,"You can display any custom types in the inspector as well by writing your own custom inspectors. You can do this by adding the ",Object(r.b)("inlineCode",{parentName:"p"},"CustomInspector")," attribute on the class that you want to make a custom inspector for (YourClass in the example below). The attribute takes in a single parameter which is the Type of the ",Object(r.b)("inlineCode",{parentName:"p"},"Inspector")," subclass that manages the UI for the class (YourClassInspector in the example). Note that the ",Object(r.b)("inlineCode",{parentName:"p"},"Inspector")," subclass is wrapped in ",Object(r.b)("em",{parentName:"p"},"#"),"if/",Object(r.b)("em",{parentName:"p"},"#"),"endif so that it is only compiled into debug builds."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Inspector")," class provides several helpers to assist with making custom inspectors. It will cache access to the getter/setter for the field/property for easy access. It wraps access to the getter/setter via the ",Object(r.b)("inlineCode",{parentName:"p"},"GetValue")," and ",Object(r.b)("inlineCode",{parentName:"p"},"SetValue")," methods which are generic and take care of casting for you. If you want to add your own custom attributes on the field/property they are accessible via the ",Object(r.b)("inlineCode",{parentName:"p"},"GetFieldOrPropertyAttribute")," generic method."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},"[CustomInspector( typeof( YourClassInspector ) )]\npublic class YourClass\n{\n    bool _isBlue { get; set; }\n    float _friction;\n    // the rest of your class\n}\n\n\n#if DEBUG\npublic class YourClassInspector : Inspector\n{\n    // this is where you setup your UI and add it to the table\n    public override void Initialize( Table table, Skin skin )\n    {}\n\n    // this is where you update the UI\n    public override void Update()\n    {}\n}\n#endif\n")))}p.isMDXComponent=!0}}]);