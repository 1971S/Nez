(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{113:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),l=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function b(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?b(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var u=l.a.createContext({}),o=function(e){var t=l.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=o(e.components);return l.a.createElement(u.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},d=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,b=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=o(n),d=a,m=p["".concat(b,".").concat(d)]||p[d]||s[d]||r;return n?l.a.createElement(m,i(i({ref:t},u),{},{components:n})):l.a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,b=new Array(r);b[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,b[1]=i;for(var u=2;u<r;u++)b[u]=n[u];return l.a.createElement.apply(null,b)}return l.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},84:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return o}));var a=n(3),l=n(7),r=(n(0),n(113)),b={id:"Collections",title:"Collections"},i={unversionedId:"features/Utils/Collections",id:"features/Utils/Collections",isDocsHomePage:!1,title:"Collections",description:".Net has already implemented the most common Collections, Nez adds several flexible collections, which can help you optimize your game.",source:"@site/docs\\features\\Utils\\Collections.md",slug:"/features/Utils/Collections",permalink:"/Nez/docs/features/Utils/Collections",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/Utils/Collections.md",version:"current",sidebar:"someSidebar",previous:{title:"Tweening",permalink:"/Nez/docs/features/Utils/Tweening"},next:{title:"Pooling",permalink:"/Nez/docs/features/Utils/Pooling"}},c=[{value:"Deque",id:"deque",children:[{value:"Usage",id:"usage",children:[]},{value:"Implementation",id:"implementation",children:[]}]},{value:"FastList",id:"fastlist",children:[{value:"Usage",id:"usage-1",children:[]}]},{value:"Pair",id:"pair",children:[{value:"Usage",id:"usage-2",children:[]},{value:"Alternatives",id:"alternatives",children:[]}]},{value:"PriorityQueue",id:"priorityqueue",children:[{value:"Usage",id:"usage-3",children:[]}]}],u={toc:c};function o(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,".Net has already implemented the most common Collections, Nez adds several flexible collections, which can help you optimize your game."),Object(r.b)("h2",{id:"deque"},"Deque"),Object(r.b)("p",null,"The deque is a Queue where you can add and remove items at the front as well as at the end with a time complexity of ",Object(r.b)("inlineCode",{parentName:"p"},"O(1)"),"."),Object(r.b)("h3",{id:"usage"},"Usage"),Object(r.b)("h4",{id:"add-and-addback"},"Add and AddBack"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Add")," and ",Object(r.b)("inlineCode",{parentName:"p"},"AddBack")," functions allows you to add Items to the back of the ",Object(r.b)("inlineCode",{parentName:"p"},"Deque")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"deque.AddBack(1);\ndeque.Add(2); //Add is added to implement ICollection<T> and calls AddBack\ndeque.AddBack(3);\n")),Object(r.b)("p",null,"The queue now looks like this\n",Object(r.b)("inlineCode",{parentName:"p"},"back [3,2,1] front")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"int a = deque.RemoveFront(); // 1\nint b = deque.RemoveFront(); // 2\nint c = deque.RemoveFront(); // 3\n")),Object(r.b)("p",null,"If we had executed this instead"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"int a = deque.RemoveBack(); // 3\nint b = deque.RemoveBack(); // 2\nint c = deque.RemoveBack(); // 1\n")),Object(r.b)("h4",{id:"addfront"},"AddFront"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"AddFront")," function allows you to add Items to the front of the ",Object(r.b)("inlineCode",{parentName:"p"},"Deque"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"var deque = new Deque<int>();\ndeque.AddFront(1);\ndeque.AddFront(2);\ndeque.AddFront(3);\n")),Object(r.b)("p",null,"The queue now looks like this\n",Object(r.b)("inlineCode",{parentName:"p"},"back [1,2,3] front")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"int a = deque.RemoveFront(); // 3\nint b = deque.RemoveFront(); // 2\nint c = deque.RemoveFront(); // 1\n")),Object(r.b)("p",null,"If we had executed this instead"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"int a = deque.RemoveBack(); // 1\nint b = deque.RemoveBack(); // 2\nint c = deque.RemoveBack(); // 3\n")),Object(r.b)("h3",{id:"implementation"},"Implementation"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Deque")," is implemented with a circular array"),Object(r.b)("p",null,"The following insertions"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"var deque = new Deque<char>();\ndeque.AddBack('a');\ndeque.AddBack('b');\ndeque.AddBack('c');\n")),Object(r.b)("p",null,"Result in the following buffer"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Index"),Object(r.b)("th",{parentName:"tr",align:null},"0"),Object(r.b)("th",{parentName:"tr",align:null},"1"),Object(r.b)("th",{parentName:"tr",align:null},"2"),Object(r.b)("th",{parentName:"tr",align:null},"3"),Object(r.b)("th",{parentName:"tr",align:null},"4"),Object(r.b)("th",{parentName:"tr",align:null},"5"),Object(r.b)("th",{parentName:"tr",align:null},".."),Object(r.b)("th",{parentName:"tr",align:null},"15"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Value"),Object(r.b)("td",{parentName:"tr",align:null},"a"),Object(r.b)("td",{parentName:"tr",align:null},"b"),Object(r.b)("td",{parentName:"tr",align:null},"c"),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("p",null,"If we then run ",Object(r.b)("inlineCode",{parentName:"p"},"RemoveFront")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"deque.RemoveFront();\n")),Object(r.b)("p",null,"The buffer will look like this"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Index"),Object(r.b)("th",{parentName:"tr",align:null},"0"),Object(r.b)("th",{parentName:"tr",align:null},"1"),Object(r.b)("th",{parentName:"tr",align:null},"2"),Object(r.b)("th",{parentName:"tr",align:null},"3"),Object(r.b)("th",{parentName:"tr",align:null},"4"),Object(r.b)("th",{parentName:"tr",align:null},"5"),Object(r.b)("th",{parentName:"tr",align:null},".."),Object(r.b)("th",{parentName:"tr",align:null},"15"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Value"),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null},"b"),Object(r.b)("td",{parentName:"tr",align:null},"c"),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("p",null,"If we then run ",Object(r.b)("inlineCode",{parentName:"p"},"AddFront")," twice\nthe front index continues on the other side of the buffer"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"deque.AddFront('d');\ndeque.AddFront('e');\n")),Object(r.b)("p",null,"The buffer will look like this"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Index"),Object(r.b)("th",{parentName:"tr",align:null},"0"),Object(r.b)("th",{parentName:"tr",align:null},"1"),Object(r.b)("th",{parentName:"tr",align:null},"2"),Object(r.b)("th",{parentName:"tr",align:null},"3"),Object(r.b)("th",{parentName:"tr",align:null},"4"),Object(r.b)("th",{parentName:"tr",align:null},"5"),Object(r.b)("th",{parentName:"tr",align:null},".."),Object(r.b)("th",{parentName:"tr",align:null},"15"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Value"),Object(r.b)("td",{parentName:"tr",align:null},"d"),Object(r.b)("td",{parentName:"tr",align:null},"b"),Object(r.b)("td",{parentName:"tr",align:null},"c"),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null},"e")))),Object(r.b)("p",null,"By keeping track of the front and the back, the items do not have to be continually shifted around, which makes the add and remove complexity ",Object(r.b)("inlineCode",{parentName:"p"},"O(1)"),"."),Object(r.b)("h2",{id:"fastlist"},"FastList"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"FastList")," is a wrapper around an ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," that auto-expands it when it reaches capacity."),Object(r.b)("h3",{id:"usage-1"},"Usage"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"FastList<int> fastList = new FastList<int>();\n")),Object(r.b)("h4",{id:"adding-items"},"Adding items"),Object(r.b)("p",null,"You can add items with ",Object(r.b)("inlineCode",{parentName:"p"},"Add")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"fastList.Add(1);\n")),Object(r.b)("p",null,"And multiple items at once with ",Object(r.b)("inlineCode",{parentName:"p"},"AddRange")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"fastList.AddRange(Enumerable.Range(1,5));\n")),Object(r.b)("h4",{id:"removing-items"},"Removing items"),Object(r.b)("p",null,"You can remove items based on value.\nThis requires traversing the list to find the item and shifting which results in a complexity of ",Object(r.b)("inlineCode",{parentName:"p"},"O(n)")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"fastList.Remove(1);\n")),Object(r.b)("p",null,"You can also remove items based on index, but this still requires the elements to be shifted which results in a complexity of ",Object(r.b)("inlineCode",{parentName:"p"},"O(n)"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"fastList.RemoveAt(0);\n")),Object(r.b)("p",null,"The fastest method is ",Object(r.b)("inlineCode",{parentName:"p"},"RemoveAtWithSwap"),". Here the item is swapped with the item at the end of the list and then deleted, which results in a complexity of ",Object(r.b)("inlineCode",{parentName:"p"},"O(1)"),".\nThe disadvantage of this method is that the order is no longer correct."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"fastList.RemoveAtWithSwap(1);\n")),Object(r.b)("h4",{id:"iterating"},"Iterating"),Object(r.b)("p",null,"When iterating the List, it is important that you use ",Object(r.b)("inlineCode",{parentName:"p"},"FastList.Length")," instead of the Buffer length"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"for (var i = 0; i < fastList.Length; i++)\n{\n    var item = fastList.Buffer[i];\n}\n")),Object(r.b)("h2",{id:"pair"},"Pair"),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"Pair")," is a simple mutable structure for managing a two objects"),Object(r.b)("h3",{id:"usage-2"},"Usage"),Object(r.b)("p",null,"Creating a pair"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"var twoNumbersPair = new Pair<object>(1, 2);\n")),Object(r.b)("p",null,"Unlike ",Object(r.b)("inlineCode",{parentName:"p"},"Tuples"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Pairs")," are mutable"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"twoNumbersPair.First = 3;\ntwoNumbersPair.Second = 4;\n")),Object(r.b)("p",null,"You can use the ",Object(r.b)("inlineCode",{parentName:"p"},"Clear")," method to set pair items to ",Object(r.b)("inlineCode",{parentName:"p"},"null")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"twoNumbersPair.Clear();\n")),Object(r.b)("h3",{id:"alternatives"},"Alternatives"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"Tuple"))),Object(r.b)("p",null,"As an alternative to ",Object(r.b)("inlineCode",{parentName:"p"},"Pair"),", you can also use the dotnet ",Object(r.b)("inlineCode",{parentName:"p"},"Tuples")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"var twoNumbersTuple = new Tuple<int, int>(1, 2);\n")),Object(r.b)("p",null,"One limitation of ",Object(r.b)("inlineCode",{parentName:"p"},"Tuples")," is that they are immutable."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"ValueTuples"))),Object(r.b)("p",null,"You can also use ",Object(r.b)("inlineCode",{parentName:"p"},"ValueTuples")," like this."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"var twoNumbersValueTuple = new ValueTuple<int, int>(1, 2);\ntwoNumbersValueTuple.Item1 = 3;\ntwoNumbersValueTuple.Item1 = 4;\n")),Object(r.b)("p",null,"Or use the ",Object(r.b)("inlineCode",{parentName:"p"},"C# 7.0")," declaration"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"(int, int) twoNumbersValueTuple;\ntwoNumbersValueTuple.Item1 = 3;\ntwoNumbersValueTuple.Item1 = 4;\n")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"(int first, int second) twoNumbersValueTuple;\ntwoNumbersValueTuple.first = 3;\ntwoNumbersValueTuple.second = 4;\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"ValueTuples")," are value types though, so they are passed by value instead of reference. You can partially get around this by using the ",Object(r.b)("inlineCode",{parentName:"p"},"ref")," keyword."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"void SomeFunction(ref (int first, int second) twoNumbersValueTuple)\n{\n    twoNumbersValueTuple.first = 3;\n    twoNumbersValueTuple.second = 4;\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"(int first, int second) twoNumbersValueTuple = default;\nSomeFunction(ref twoNumbersValueTuple);\n")),Object(r.b)("p",null,"Overview for each situation"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Mutable"),Object(r.b)("th",{parentName:"tr",align:null},"Immutable"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},"ReferenceType")),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("inlineCode",{parentName:"td"},"Pair")),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("inlineCode",{parentName:"td"},"Tuple"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},"ValueType")),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("inlineCode",{parentName:"td"},"ValueTuple")),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h2",{id:"priorityqueue"},"PriorityQueue"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"PriorityQueue")," is a data structure that allows you to prioritize elements very efficiently. This is useful for example for algorithms like ",Object(r.b)("inlineCode",{parentName:"p"},"A*")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Dijkstra's Shortest Path"),"."),Object(r.b)("h3",{id:"usage-3"},"Usage"),Object(r.b)("p",null,"For this example, I am using SimplePriorityQueue. "),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"var queue = new SimplePriorityQueue<int>();\nqueue.Enqueue(3,3);\nqueue.Enqueue(2,2);\nqueue.Enqueue(1,1);\nqueue.Enqueue(4,4);\nqueue.Enqueue(5,5);\n")),Object(r.b)("p",null,"The first parameter of ",Object(r.b)("inlineCode",{parentName:"p"},"Enqueue")," is the ",Object(r.b)("inlineCode",{parentName:"p"},"value"),". The second parameter is the ",Object(r.b)("inlineCode",{parentName:"p"},"priority"),".\nFor this example, I'll use the same value."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cs"},"int value1 = queue.Dequeue(); // 1\nint value2 = queue.Dequeue(); // 2\nint value3 = queue.Dequeue(); // 3\nint value4 = queue.Dequeue(); // 4\nint value5 = queue.Dequeue(); // 5\n")),Object(r.b)("p",null,"As you can see, the values are coming out sorted from the ",Object(r.b)("inlineCode",{parentName:"p"},"PriorityQueue")),Object(r.b)("p",null,"For understanding the internal workings of the PriorityQueue, I recommend you to read ",Object(r.b)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/binary-heap/"},"this"),"."))}o.isMDXComponent=!0}}]);