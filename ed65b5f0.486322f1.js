(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{107:function(e,t,i){"use strict";i.d(t,"a",(function(){return u})),i.d(t,"b",(function(){return y}));var o=i(0),s=i.n(o);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,o)}return i}function l(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,o,s=function(e,t){if(null==e)return{};var i,o,s={},n=Object.keys(e);for(o=0;o<n.length;o++)i=n[o],t.indexOf(i)>=0||(s[i]=e[i]);return s}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)i=n[o],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(s[i]=e[i])}return s}var c=s.a.createContext({}),h=function(e){var t=s.a.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):l(l({},t),e)),i},u=function(e){var t=h(e.components);return s.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},p=s.a.forwardRef((function(e,t){var i=e.components,o=e.mdxType,n=e.originalType,a=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=h(i),p=o,y=u["".concat(a,".").concat(p)]||u[p]||d[p]||n;return i?s.a.createElement(y,l(l({ref:t},c),{},{components:i})):s.a.createElement(y,l({ref:t},c))}));function y(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=i.length,a=new Array(n);a[0]=p;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var c=2;c<n;c++)a[c]=i[c];return s.a.createElement.apply(null,a)}return s.a.createElement.apply(null,i)}p.displayName="MDXCreateElement"},99:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return a})),i.d(t,"metadata",(function(){return l})),i.d(t,"toc",(function(){return r})),i.d(t,"default",(function(){return h}));var o=i(3),s=i(7),n=(i(0),i(107)),a={id:"NezPhysics",title:"Nez Physics/Collisions"},l={unversionedId:"features/Physics/NezPhysics",id:"features/Physics/NezPhysics",isDocsHomePage:!1,title:"Nez Physics/Collisions",description:"It serves to reiterate what has been stated before: Nez physics is not a realistic physics simulation. It provides what I call game physics. You can do things like linecasts to detect colliders, overlap checks, collision checks, sweep tests and more. What you don't get is a full rigid body simulation. You get to control your game's feel from top to bottom. If you are looking for a full physics simulation see the optional Farseer Physics implementation.",source:"@site/docs\\features\\Physics\\NezPhysics.md",slug:"/features/Physics/NezPhysics",permalink:"/Nez/docs/features/Physics/NezPhysics",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/Physics/NezPhysics.md",version:"current",sidebar:"someSidebar",previous:{title:"Pathfinding",permalink:"/Nez/docs/features/AI/Pathfinding"},next:{title:"Verlet Physics",permalink:"/Nez/docs/features/Physics/Verlet"}},r=[{value:"Colliders: The Root of the Physics System",id:"colliders-the-root-of-the-physics-system",children:[]},{value:"The SpatialHash: You&#39;ll never touch it but it&#39;s still important",id:"the-spatialhash-youll-never-touch-it-but-its-still-important",children:[]},{value:"The Physics Class",id:"the-physics-class",children:[]},{value:"Putting the Physics System to Use",id:"putting-the-physics-system-to-use",children:[]}],c={toc:r};function h(e){var t=e.components,i=Object(s.a)(e,["components"]);return Object(n.b)("wrapper",Object(o.a)({},c,i,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"It serves to reiterate what has been stated before: Nez physics is ",Object(n.b)("em",{parentName:"p"},"not")," a realistic physics simulation. It provides what I call ",Object(n.b)("em",{parentName:"p"},"game")," physics. You can do things like linecasts to detect colliders, overlap checks, collision checks, sweep tests and more. What you don't get is a full rigid body simulation. ",Object(n.b)("em",{parentName:"p"},"You")," get to control your game's feel from top to bottom. If you are looking for a full physics simulation see the optional ",Object(n.b)("a",{parentName:"p",href:"/Nez/docs/features/Physics/FarseerPhysics"},"Farseer Physics implementation"),"."),Object(n.b)("h2",{id:"colliders-the-root-of-the-physics-system"},"Colliders: The Root of the Physics System"),Object(n.b)("p",null,"Nothing happens in the physics system without Colliders. Colliders live on the Entity class and come in several varieties: BoxCollider, CircleCollider and PolygonCollider. You can add a Collider like so: ",Object(n.b)("inlineCode",{parentName:"p"},"entity.AddComponent( new BoxCollider() )"),". When you have debugRender enabled Colliders will be displayed with red lines (to enable debugRender either set ",Object(n.b)("inlineCode",{parentName:"p"},"Core.DebugRenderEnabled = true"),' or open the console and type "debug-render"). Colliders are automatically added to the SpatialHash when you add them to an Entity, which brings us to our next topic.'),Object(n.b)("h2",{id:"the-spatialhash-youll-never-touch-it-but-its-still-important"},"The SpatialHash: You'll never touch it but it's still important"),Object(n.b)("p",null,"Under the covers lies the SpatialHash class which manages Colliders globally for your game. The static ",Object(n.b)("strong",{parentName:"p"},"Physics")," class is the public wrapper for the SpatialHash. The SpatialHash has no set size limits and is used to make collision/linecast/overlap checks really fast. As an example, if you have a hero moving around the world instead of having to check every Collider (which could be hundreds) for a collision you can just ask the SpatialHash for all the Colliders near your hero. That narrows down your collision checks drastically."),Object(n.b)("p",null,"There is one configurable aspect to the SpatialHash that can greatly affect how performant it is: the cell size. The SpatialHash splits up space into a grid and choosing a proper grid size can keep your possible collision queries to a minimum. By default the grid size is 100 pixels. You can change this by setting ",Object(n.b)("inlineCode",{parentName:"p"},"Physics.SpatialHashCellSize")," ",Object(n.b)("em",{parentName:"p"},"before")," creating a Scene. Choosing a size that is slightly larger than your average player/enemy size usually works best."),Object(n.b)("p",null,"One last thing about the SpatialHash: it includes a visual debugger. By pulling up the in-game console (press the tilde key) and running the command ",Object(n.b)("strong",{parentName:"p"},"physics")," the SpatialHash grid and number of objects in each cell will be displayed. This is handy for helping to decide what your spatialHashCellSize should be."),Object(n.b)("h2",{id:"the-physics-class"},"The Physics Class"),Object(n.b)("p",null,"The ",Object(n.b)("strong",{parentName:"p"},"Physics")," class is your gateway to all things Physics. There are some properties you can set such as the aforementioned spatialHashCellSize, raycastsHitTriggers and raycastsStartInColliders. See the intellisense docs for an explanation of each. Some of the more useful and commonly used methods are:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"Linecast"),": casts a line from start to end and returns the first hit of a collider that matches layerMask"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"OverlapRectangle"),": check if any collider falls within a rectangular area"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"OverlapCircle"),": check if any collider falls within a circular area"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"BoxcastBroadphase"),": returns all colliders with bounds that are intersected by collider.bounds. Note that this is a broadphase check so it only checks bounds and does not do individual Collider-to-Collider checks!")),Object(n.b)("p",null,"Astute readers will have noticed the ",Object(n.b)("em",{parentName:"p"},"layerMask")," mentioned above. The layerMask lets you decide which colliders are collided with. Each Collider can have its ",Object(n.b)("inlineCode",{parentName:"p"},"PhysicsLayer")," set so that when you query the Physics system you can choose to get back only Colliders that match the passed in layerMask. All Physics methods accept a layerMask parameter that defaults to all layers. Use this wisely to filter your collision checks and keep things as performant as possible by not doing unnecessary collision checks."),Object(n.b)("h2",{id:"putting-the-physics-system-to-use"},"Putting the Physics System to Use"),Object(n.b)("p",null,"Linecasts are extremely useful for various things like checking line-of-sight for enemies, detecting the spatial surroundings of an Entity, fast-moving bullets, etc. Here is an example of casting a line from start to end that just logs the data if it hits something:"),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre",className:"language-csharp"},'var hit = Physics.Linecast( start, end );\nif( hit.Collider != null )\n    Debug.Log( "ray hit {0}, entity: {1}", hit, hit.collider.entity );\n')),Object(n.b)("p",null,"Nez has some more advanced collision/overlap checks using methods such as Minkowski Sums, Separating Axis Theorem and good old trigonometry. These are all wrapped up in simple to use methods on the Collider class for you. Lets take a look at some examples."),Object(n.b)("p",null,"This first example is the easiest way to deal with collisions. ",Object(n.b)("inlineCode",{parentName:"p"},"deltaMovement")," is the amount that you would like to move the Entity, typically ",Object(n.b)("inlineCode",{parentName:"p"},"velocity * Time.DeltaTime"),". The ",Object(n.b)("inlineCode",{parentName:"p"},"CollidesWithAny")," method will check all collisons and adjust deltaMovement to resolve any collisions."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre",className:"language-csharp"},'// CollisionResult will contain some really useful information such as the Collider that was hit,\n// the normal of the surface hit and the minimum translation vector (MTV). The MTV can be used to\n// move the colliding Entity directly adjacent to the hit Collider.\nCollisionResult collisionResult;\n\n// do a check to see if entity.getComponent<Collider> (the first Collider on the Entity) collides with any other Colliders in the Scene\n// Note that if you have multiple Colliders you could fetch and loop through them instead of only checking the first one.\nif( entity.GetComponent<Collider>().CollidesWithAny( ref deltaMovement, out collisionResult ) )\n{\n    // log the CollisionResult. You may want to use it to add some particle effects or anything else relevant to your game.\n    Debug.Log( "collision result: {0}", collisionResult );\n}\n\n// move the Entity to the new position. deltaMovement is already adjusted to resolve collisions for us.\nentity.Position += deltaMovement;\n')),Object(n.b)("p",null,"If you need a bit more control over what happens when a collision occurs you can manually check for collisions with other Colliders as well. This next snippet checks for a collision with a specific Collider. Note that when doing this deltaMovement is not adjust for you. It is up to you to take into account the ",Object(n.b)("inlineCode",{parentName:"p"},"MinimumTranslationVector")," when resolving the collision."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre",className:"language-csharp"},'// declare the CollisionResult\nCollisionResult collisionResult;\n\n// do a check to see if entity.getComponent<Collider> collides with someOtherCollider\nif( entity.GetComponent<Collider>().CollidesWith( someOtherCollider, deltaMovement, out collisionResult ) )\n{\n    // move entity to the position directly adjacent to the hit Collider then log the CollisionResult\n    entity.Position += deltaMovement - collisionResult.MinimumTranslationVector;\n    Debug.Log( "collision result: {0}", collisionResult );\n}\n')),Object(n.b)("p",null,"We can take the above example a step further using the previously mentioned ",Object(n.b)("inlineCode",{parentName:"p"},"Physics.BoxcastBroadphase")," method, or more specifically a version of it that excludes ourself from the query. That method will give us all the colliders in the Scene that are in our vicinity which we can then use to do our actual collision checks on."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre",className:"language-csharp"},'// fetch anything that we might overlap with at our position excluding ourself. We don\'t care about ourself here.\nvar neighborColliders = Physics.BoxcastBroadphaseExcludingSelf( entity.GetComponent<Collider>() );\n\n// loop through and check each Collider for an overlap\nforeach( var collider in neighborColliders )\n{\n    if( entity.GetComponent<Collider>().Overlaps( collider ) )\n        Debug.Log( "We are overlapping a Collider: {0}", collider );\n}\n')))}h.isMDXComponent=!0}}]);