(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{113:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return p}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),d=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,p=u["".concat(o,".").concat(h)]||u[h]||b[h]||r;return n?i.a.createElement(p,l(l({ref:t},c),{},{components:n})):i.a.createElement(p,l({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},80:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return d}));var a=n(3),i=n(7),r=(n(0),n(113)),o={id:"Behavior",title:"Behavior"},l={unversionedId:"features/AI/Behavior",id:"features/AI/Behavior",isDocsHomePage:!1,title:"Behavior",description:"Nez includes several different options for setting up AI ranging from a super simple transitionless finite state machine (FSM) to extendable behavior trees to ultra-flexible Utility Based AI. You can mix and match them as you see fit.",source:"@site/docs\\features\\AI\\Behavior.md",slug:"/features/AI/Behavior",permalink:"/Nez/docs/features/AI/Behavior",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/AI/Behavior.md",version:"current",sidebar:"someSidebar",previous:{title:"Dear IMGUI",permalink:"/Nez/docs/features/UI/DearImGui"},next:{title:"Pathfinding",permalink:"/Nez/docs/features/AI/Pathfinding"}},s=[{value:"Composites",id:"composites",children:[]},{value:"Conditionals",id:"conditionals",children:[]},{value:"Decorators",id:"decorators",children:[]},{value:"Actions",id:"actions",children:[]},{value:"ActionPlanner",id:"actionplanner",children:[]},{value:"Action/ActionT",id:"actionactiont",children:[]},{value:"Agent",id:"agent",children:[]},{value:"Reasoner",id:"reasoner",children:[]},{value:"Consideration",id:"consideration",children:[]},{value:"Appraisal",id:"appraisal",children:[]},{value:"Action",id:"action",children:[]}],c={toc:s};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Nez includes several different options for setting up AI ranging from a super simple transitionless finite state machine (FSM) to extendable behavior trees to ultra-flexible Utility Based AI. You can mix and match them as you see fit."),Object(r.b)("h1",{id:"simple-state-machine"},"Simple State Machine"),Object(r.b)("p",null,"The fastest and easiest way to get AI up and running. ",Object(r.b)("inlineCode",{parentName:"p"},"SimpleStateMachine")," is a Component subclass that lets you set an enum as its generic constraint and it will use that enum to control the state machine. The enum values each map to a state and can have optional enter/tick/exit methods. The naming conventions for these methods are best shown with an example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},"enum SomeEnum\n{\n    Walking,\n    Idle\n}\n\npublic class YourClass : SimpleStateMachine<SomeEnum>()\n{\n    void OnAddedToEntity()\n    {\n        initialState = SomeEnum.Idle;\n    }\n\n    void Walking_Enter() {}\n    void Walking_Tick() {}\n    void Walking_Exit() {}\n\n    void Idle_Enter() {}\n    void Idle_Tick() {}\n    void Idle_Exit() {}\n}\n")),Object(r.b)("h1",{id:"state-machine"},"State Machine"),Object(r.b)("p",null,"The next step up is ",Object(r.b)("inlineCode",{parentName:"p"},"StateMachine"),' which implements the "states as objects" pattern. ',Object(r.b)("inlineCode",{parentName:"p"},"StateMachine")," uses separate classes for each state so it is a better choice for more complex systems."),Object(r.b)("p",null,"We start to get into the concept of a ",Object(r.b)("inlineCode",{parentName:"p"},"context")," with ",Object(r.b)("inlineCode",{parentName:"p"},"StateMachine"),". In coding, the context is just the class used to satisfy a generic constraint. in a ",Object(r.b)("inlineCode",{parentName:"p"},"List<string>")," the ",Object(r.b)("em",{parentName:"p"},"string")," would be the context class, the class that the list operates on. With all of the rest of the AI solutions you get to specify the context class. It could be your Enemy class, Player class or a helper object that contains any information relevant to your AI (such as the Player, a list of Enemies, navigation information, etc)."),Object(r.b)("p",null,"Here is a simple example showing the usage (with the State subclasses omitted for brevity):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-csharp"},"// create a state machine that will work with an object of type SomeClass as the focus with an initial state of PatrollingState\nvar machine = new SKStateMachine<SomeClass>( someClass, new PatrollingState() );\n\n// we can now add any additional states\nmachine.AddState( new AttackState() );\nmachine.AddState( new ChaseState() );\n\n// this method would typically be called in an update of an object\nmachine.Update( Time.deltaTime );\n\n// change states. the state machine will automatically create and cache an instance of the class (in this case ChasingState)\nmachine.ChangeState<ChasingState>();\n")),Object(r.b)("h1",{id:"behavior-trees"},"Behavior Trees"),Object(r.b)("p",null,"The de facto standard for composing AI for the last decade. Behavior trees are composed of a tree of nodes. Nodes can make decisions and perform actions based on the state of the world. Nez includes a ",Object(r.b)("inlineCode",{parentName:"p"},"BehaviorTreeBuilder")," class that provides a fluent API for setting up a behavior tree. The ",Object(r.b)("inlineCode",{parentName:"p"},"BehaviorTreeBuilder")," is a great way to reduce the barrier of entry to using behavior trees and get up and running quickly."),Object(r.b)("h2",{id:"composites"},"Composites"),Object(r.b)("p",null,"Composites are parent nodes in a behavior tree. They house 1 or more children and execute them in different ways."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Sequence<T>:")," returns failure as soon as one of its children returns failure. If a child returns success it will sequentially run the next child in the next tick of the tree."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Selector<T>:")," returns success as soon as one of its child tasks return success. If a child task returns failure then it will sequentially run the next child in the next tick."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Parallel<T>:")," runs each child until a child returns failure. It differs from ",Object(r.b)("inlineCode",{parentName:"li"},"Sequence")," only in that it runs all children every tick"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ParallelSelector<T>:")," like a ",Object(r.b)("inlineCode",{parentName:"li"},"Selector")," except it will run all children every tick"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"RandomSequence<T>:")," a ",Object(r.b)("inlineCode",{parentName:"li"},"Sequence")," that shuffles its children before executing"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"RandomSelector<T>:")," a ",Object(r.b)("inlineCode",{parentName:"li"},"Selector")," that shuffles its children before executing")),Object(r.b)("h2",{id:"conditionals"},"Conditionals"),Object(r.b)("p",null,"Conditionals are binary success/failure nodes. They are identified by the IConditional interface. They check some condition of your game world and either return success or failure. These are inherently game specific so Nez only provides a single generic Conditional out of the box and a helper Conditional that wraps an Action so you can avoid having to make a separate class for each Conditional."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"RandomProbability<T>:")," return success when the random probability is above the specified success probability"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ExecuteActionConditional<T>:")," wraps a Func and executes it as the Conditional. Useful for prototyping and to avoid creating separate classes for simple Conditionals.")),Object(r.b)("h2",{id:"decorators"},"Decorators"),Object(r.b)("p",null,"Decorators are wrapper tasks that have a single child. They can modify the behavior of the child task in various ways such as inverting the result, running it until failure, etc."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"AlwaysFail<T>:")," always returns failure regardless of the child result"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"AlwaysSucceed<T>:")," always returns success regardless of the child result"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ConditionalDecorator<T>:")," wraps a Conditional and will only run its child if a condition is met"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Inverter<T>:")," inverts the result of its child"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Repeater<T>:")," repeats its child task a specified number of times"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"UntilFail<T>:")," keeps executing its child task until it returns failure"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"UntilSuccess<T>:")," keeps executing its child task until it returns success")),Object(r.b)("h2",{id:"actions"},"Actions"),Object(r.b)("p",null,"Actions are the leaf nodes of the behavior tree. This is where stuff happens such as playing an animation, triggering an event, etc."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ExecuteAction<T>:")," wraps a Func and executes it as its action. Useful for prototyping and to avoid creating separate classes for simple Actions."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"WaitAction<T>:")," waits a specified amount of time"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"LogAction<T>:")," logs a string to the console. Useful for debugging."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"BehaviorTreeReference<T>:")," runs another ",Object(r.b)("inlineCode",{parentName:"li"},"BehaviorTree<T>"))),Object(r.b)("h1",{id:"goal-oriented-action-planning-goap"},"Goal Oriented Action Planning (GOAP)"),Object(r.b)("p",null,"GOAP differs quite a bit from the other AI solutions. With GOAP, you provide the planner with a list of the actions that the AI can perform, the current world state and the desired world state (goal state). GOAP will then attempt to find a series of actions that will get the AI to the goal state."),Object(r.b)("p",null,"GOAP was made popular by the old FPS F.E.A.R. The AI in F.E.A.R. consisted of a GOAP and a state machine with just 3 states: GoTo, Animate, UseSmartObject. Jeff Orkin's ",Object(r.b)("a",{parentName:"p",href:"http://alumni.media.mit.edu/~jorkin/goap.html"},"web page")," is a treasure trove of great information."),Object(r.b)("h2",{id:"actionplanner"},"ActionPlanner"),Object(r.b)("p",null,"The brains of the operation. You give the ActionPlanner all of your Actions, the current world state and your goal state and it will give you back the best possible plan to achieve the goal state."),Object(r.b)("h2",{id:"actionactiont"},"Action/ActionT"),Object(r.b)("p",null,"Actions define a list of pre conditions that they require and a list of post conditions that will occur when the Action is performed. ActionT is just a subclass of Action with a handy context object of type T."),Object(r.b)("h2",{id:"agent"},"Agent"),Object(r.b)("p",null,"Agent is a helper class that encapsulates an AI agent. It keeps a list of available Actions and a reference to the ActionPlanner. Agent is abstract and requires you to define the ",Object(r.b)("inlineCode",{parentName:"p"},"GetWorldState")," and ",Object(r.b)("inlineCode",{parentName:"p"},"GetGoalState")," methods. With those in place getting a plan is as simple as calling ",Object(r.b)("inlineCode",{parentName:"p"},"agent.Plan()"),"."),Object(r.b)("h1",{id:"utility-based-ai"},"Utility Based AI"),Object(r.b)("p",null,"Utility Theory for games. The most complex of the AI solutions. Best used in very dynamic environments where its scoring system works best. Utility based AI are more appropriate in situations where there are a large number of potentially competing actions the AI can take such as in a RTS. A great overview of utility AI is ",Object(r.b)("a",{parentName:"p",href:"http://www.gdcvault.com/play/1012410/Improving-AI-Decision-Modeling-Through"},"available here"),"."),Object(r.b)("h2",{id:"reasoner"},"Reasoner"),Object(r.b)("p",null,"Selects the best Consideration from a list of Considerations attached to the Reasoner. The root of a utility AI."),Object(r.b)("h2",{id:"consideration"},"Consideration"),Object(r.b)("p",null,"Houses a list of Appraisals and an Action. Calculates a score that represents numerically the utility of its Action."),Object(r.b)("h2",{id:"appraisal"},"Appraisal"),Object(r.b)("p",null,"One or more Appraisals can be added to a Consideration. They calculate and return a score which is used by the Consideration."),Object(r.b)("h2",{id:"action"},"Action"),Object(r.b)("p",null,"The action that the AI executes when a specific Consideration is selected."))}d.isMDXComponent=!0}}]);