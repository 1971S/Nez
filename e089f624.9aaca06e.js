(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{107:function(e,t,a){"use strict";a.d(t,"a",(function(){return c})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var h=r.a.createContext({}),l=function(e){var t=r.a.useContext(h),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=l(e.components);return r.a.createElement(h.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},g=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,h=d(e,["components","mdxType","originalType","parentName"]),c=l(a),g=n,u=c["".concat(i,".").concat(g)]||c[g]||p[g]||o;return a?r.a.createElement(u,s(s({ref:t},h),{},{components:a})):r.a.createElement(u,s({ref:t},h))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=g;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var h=2;h<o;h++)i[h]=a[h];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}g.displayName="MDXCreateElement"},94:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return d})),a.d(t,"default",(function(){return l}));var n=a(3),r=a(7),o=(a(0),a(107)),i={id:"Pathfinding",title:"Pathfinding"},s={unversionedId:"features/AI/Pathfinding",id:"features/AI/Pathfinding",isDocsHomePage:!1,title:"Pathfinding",description:"Nez provides three pathfinding algorithms out of the box: Breadth First Search, Dijkstra (weighted) and Astar (weighted with heuristic). All three are well suited for not only grid based graphs but also graphs of any type. Which algorithm should you use? That depends on your specific graph and needs. The next sections will go into a bit more detail on each of the algorithms so that you can intelligently decide which to use.",source:"@site/docs\\features\\AI\\Pathfinding.md",slug:"/features/AI/Pathfinding",permalink:"/Nez/docs/features/AI/Pathfinding",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/AI/Pathfinding.md",version:"current",sidebar:"someSidebar",previous:{title:"Behavior",permalink:"/Nez/docs/features/AI/Behavior"},next:{title:"Nez Physics/Collisions",permalink:"/Nez/docs/features/Physics/NezPhysics"}},d=[{value:"Breadth First Search",id:"breadth-first-search",children:[]},{value:"Dijkstra (aka Weighted)",id:"dijkstra-aka-weighted",children:[]},{value:"Astar",id:"astar",children:[]}],h={toc:d};function l(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},h,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Nez provides three pathfinding algorithms out of the box: Breadth First Search, Dijkstra (weighted) and Astar (weighted with heuristic). All three are well suited for not only grid based graphs but also graphs of any type. Which algorithm should you use? That depends on your specific graph and needs. The next sections will go into a bit more detail on each of the algorithms so that you can intelligently decide which to use."),Object(o.b)("p",null,"It should be noted that none of the search algorithms require the nodes searched to be locations. Pathfinding doesn't care about what data it is finding a path for. All it needs to know is the node and that node's neighbors (edges). The nodes can be anything at all: paths in a dialog tree, actions for AI (Astar is used by the Goal Oriented Action Planner) or even strings (see below for an example). Edges can be traversable one way or both ways."),Object(o.b)("p",null,"The Graph interfaces for Breadth First Search, Dijkstra and Astar are all fully generic so you get to decide what data your nodes need. In the simplest case the nodes can be a ",Object(o.b)("inlineCode",{parentName:"p"},"Point")," (see ",Object(o.b)("inlineCode",{parentName:"p"},"UnweightedGridGraph"),", ",Object(o.b)("inlineCode",{parentName:"p"},"WeightedGridGraph")," and ",Object(o.b)("inlineCode",{parentName:"p"},"AstarGridGraph")," for examples). If your nodes need a bunch of precomputed data you can use any class that you want for them. This allows you to precompute (offline or at map load time) any data that you might need for the actual path search."),Object(o.b)("h2",{id:"breadth-first-search"},"Breadth First Search"),Object(o.b)("p",null,"Often called flood fill when used on a grid, Breadth First Search uses an expanding frontier that radiates out from the start position visiting all neighbor nodes on the way. When it reaches the goal it stops the search and returns the path. If no valid path is found null is returned. Breadth First Search is well suited for graphs that have uniform traversal cost between edges."),Object(o.b)("p",null,"To implement Breadth First Search all you have to do is satisfy the single-method interface ",Object(o.b)("inlineCode",{parentName:"p"},"IUnweightedGraph<T>"),". The ",Object(o.b)("inlineCode",{parentName:"p"},"UnweightedGraph<T>")," is a concrete implementation that you can use as well (an example is below). The ",Object(o.b)("inlineCode",{parentName:"p"},"UnweightedGridGraph")," is also a concrete implementation that can be used directly or as a starting point for grid based graphs. It works out of the box for TiledMaps as well."),Object(o.b)("p",null,"Lets take a look at a functional example of a node based graph of plain old strings. This illustrates how pathfinding can be used to solve non-spatial based problems."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},'// create an UnweightedGraph with strings as nodes\nvar graph = new UnweightedGraph<string>();\n    \n// add a set of 5 nodes and edges for each\ngraph.AddEdgesForNode( "a", new string[] { "b" } ); // a\u2192b\ngraph.AddEdgesForNode( "b", new string[] { "a", "c", "d" } ); // b\u2192a, b\u2192c, b\u2192d\ngraph.AddEdgesForNode( "c", new string[] { "a" } ); // c\u2192a\ngraph.AddEdgesForNode( "d", new string[] { "e", "a" } ); // d\u2192e, d\u2192a\ngraph.AddEdgesForNode( "e", new string[] { "b" } ); // e\u2192b\n\n// calculate a path from "c" to "e". The result is c\u2192a\u2192b\u2192d\u2192e, which we can confirm by looking at the edge comments above.\nvar path = BreadthFirstPathfinder.Search( graph, "c", "e" );\n')),Object(o.b)("h2",{id:"dijkstra-aka-weighted"},"Dijkstra (aka Weighted)"),Object(o.b)("p",null,"Dijkstra expands on Breadth First Search by introducing a cost for each edge that the algorithm takes into account when pathfinding. This lends you more control over the pathfinding process. You can add edges with higher costs (moving along a road vs moving through a mud bog for example) to provide a hint that the algorithm should choose the lowest cost path. The algorithm will ask you for a cost to get from one node to another and you can choose to return any value that makes sense. It will then use the information to find not a only a path to the goal but the lowest cost path."),Object(o.b)("p",null,"To implement Dijkstra you have to provide a graph that implements the interface ",Object(o.b)("inlineCode",{parentName:"p"},"IWeightedGraph<T>"),". The ",Object(o.b)("inlineCode",{parentName:"p"},"WeightedGridGraph")," is a concrete implementation that can be used directly or as a starting point for grid based graphs. It works out of the box for TiledMaps."),Object(o.b)("p",null,"Below is an example of using the ",Object(o.b)("inlineCode",{parentName:"p"},"WeightedGridGraph")," with a TiledMap layer. A graph will be generated that uses empty space in the TiledMap as traversable nodes and any space with a tile is considered a wall. Some weighted nodes are added to take advantage of Dijkstra's specialty in dealing with nodes of non-uniform weight."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"\nvar graph = new WeightedGridGraph( tiledMapCollisionLayer );\n\n// add some weighted nodes\ngraph.WeightedNodes.Add( new Point( 3, 3 ) );\ngraph.WeightedNodes.Add( new Point( 3, 4 ) );\ngraph.WeightedNodes.Add( new Point( 4, 3 ) );\ngraph.WeightedNodes.Add( new Point( 4, 4 ) );\n\n// calculate the path\nvar path = graph.Search( new Point( 3, 4 ), new Point( 15, 17 ) );\n")),Object(o.b)("h2",{id:"astar"},"Astar"),Object(o.b)("p",null,"Astar is probably the most well known of all pathfinding algorithms. It differs from Dijkstra in that it introduces a heuristic for each edge that the algorithm takes into account when pathfinding. This lets you add some interesting elements such as edges with higher costs (moving along a road vs moving through a mud bog for example.) The algorithm will ask you for a cost to get from one node to another and you can choose to return any value that makes sense. It will then use the information to find not a only a path to the goal but the lowest cost path."),Object(o.b)("p",null,"To implement Astar you have to provide a graph that implements the interface ",Object(o.b)("inlineCode",{parentName:"p"},"IAstarGraph<T>"),". The ",Object(o.b)("inlineCode",{parentName:"p"},"AstarGridGraph")," is a concrete implementation that can be used directly or as a starting point for grid based graphs. It works out of the box for TiledMaps."),Object(o.b)("p",null,"Below is an example of using the ",Object(o.b)("inlineCode",{parentName:"p"},"AstarGridGraph")," with a TiledMap layer. A graph will be generated that uses empty space in the TiledMap as traversable nodes and any space with a tile is considered a wall. Some weighted nodes are added to take advantage of Astar's specialty in dealing with nodes of non-uniform weight."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-csharp"},"\nvar graph = new AstarGridGraph( tiledMapCollisionLayer );\n\n// add some weighted nodes\ngraph.WeightedNodes.Add( new Point( 3, 3 ) );\ngraph.WeightedNodes.Add( new Point( 3, 4 ) );\ngraph.WeightedNodes.Add( new Point( 4, 3 ) );\ngraph.WeightedNodes.Add( new Point( 4, 4 ) );\n\n// calculate the path\nvar path = graph.Search( new Point( 3, 4 ), new Point( 15, 17 ) );\n")))}l.isMDXComponent=!0}}]);