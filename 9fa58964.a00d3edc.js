(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{112:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),d=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=a,h=p["".concat(r,".").concat(m)]||p[m]||b[m]||o;return n?i.a.createElement(h,l(l({ref:t},c),{},{components:n})):i.a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},91:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return d}));var a=n(3),i=n(7),o=(n(0),n(112)),r={id:"SceneEntityComponentSystem",title:"Scene/Entity/Component System"},l={unversionedId:"features/ECS/SceneEntityComponentSystem",id:"features/ECS/SceneEntityComponentSystem",isDocsHomePage:!1,title:"Scene/Entity/Component System",description:"Most of Nez revolves around an Entity-Component system (ECS). The Nez ECS is not unlike any other ECS you may have worked with so it should be instantly familiar.",source:"@site/docs\\features\\ECS\\SceneEntityComponentSystem.md",slug:"/features/ECS/SceneEntityComponentSystem",permalink:"/Nez/docs/features/ECS/SceneEntityComponentSystem",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/ECS/SceneEntityComponentSystem.md",version:"current",sidebar:"someSidebar",previous:{title:"Farseer Physics/Collisions",permalink:"/Nez/docs/features/Physics/FarseerPhysics"},next:{title:"Scene Transitions",permalink:"/Nez/docs/features/ECS/SceneTransitions"}},s=[{value:"Scene",id:"scene",children:[]},{value:"Entity",id:"entity",children:[]},{value:"Component",id:"component",children:[]},{value:"Materials",id:"materials",children:[]}],c={toc:s};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Most of Nez revolves around an Entity-Component system (ECS). The Nez ECS is not unlike any other ECS you may have worked with so it should be instantly familiar."),Object(o.b)("h2",{id:"scene"},"Scene"),Object(o.b)("p",null,"The root of the ECS. Scenes can be thought of as the different parts of your game such as the menu, levels, credits, etc. Scenes manage a list of Entities, Renderers and PostProcessors (via add/remove methods) and call their methods at the appropriate times. You can also use the Scene to locate Entities via the ",Object(o.b)("inlineCode",{parentName:"p"},"FindEntity")," and ",Object(o.b)("inlineCode",{parentName:"p"},"FindEntitiesByTag")," methods. Scenes are also created with a Camera that you can choose to use or not."),Object(o.b)("p",null,"Scene's provide a ",Object(o.b)("inlineCode",{parentName:"p"},"NezContentManager")," in ",Object(o.b)("inlineCode",{parentName:"p"},"Scene.contentManager")," that you can use to load up scene-specific content. When the scene is finished the content will be unloaded automatically for you. If you need to load global content (anything that would be used by several scenes) you can use the ",Object(o.b)("inlineCode",{parentName:"p"},"Core.contentManager")," which is not ever explicitly unloaded."),Object(o.b)("p",null,"A Scene can contain a special kind of Component called a ",Object(o.b)("inlineCode",{parentName:"p"},"SceneComponent"),". SceneComponents are managed via the ",Object(o.b)("inlineCode",{parentName:"p"},"Add"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Get"),", ",Object(o.b)("inlineCode",{parentName:"p"},"GetOrCreate")," and ",Object(o.b)("inlineCode",{parentName:"p"},"RemoveSceneComponent")," methods. A ",Object(o.b)("inlineCode",{parentName:"p"},"SceneComponent")," can be thought of as a simplified Component. It contains a small amount of lifecycle methods that are overrideable (",Object(o.b)("inlineCode",{parentName:"p"},"OnEnabled"),", ",Object(o.b)("inlineCode",{parentName:"p"},"OnDisabled"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Update")," and ",Object(o.b)("inlineCode",{parentName:"p"},"OnRemovedFromScene"),"). These can be used when you need an object that lives at the ",Object(o.b)("inlineCode",{parentName:"p"},"Scene")," level but does not require an ",Object(o.b)("inlineCode",{parentName:"p"},"Entity")," container. One example included with Nez is the Farseer world object which manages the physics simulation."),Object(o.b)("p",null,"Nez provides several different ways to get your final scene rendered flexibly and efficiently. It uses a concept called ",Object(o.b)("inlineCode",{parentName:"p"},"SceneResolutionPolicy")," to manage how things are rendered. The ",Object(o.b)("inlineCode",{parentName:"p"},"SceneResolutionPolicy")," along with the design time width/height that you set decides what size the RenderTarget2D should be and how it changes when the window size changes. Several SceneResolutionPolicys also include pixel perfect variants for use with pixal art games. Pixel perfect variants may end up with letter/pillar boxing which you can control via the ",Object(o.b)("strong",{parentName:"p"},"Scene.LetterboxColor"),". You can set the default ",Object(o.b)("inlineCode",{parentName:"p"},"SceneResolutionPolicy")," used for all scenes by calling ",Object(o.b)("strong",{parentName:"p"},"Scene.SetDefaultDesignResolution"),". The included SceneResolutionPolicys are below:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"None"),": Default. RenderTarget2D matches the sceen size"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"ExactFit"),": The entire application is visible in the specified area without trying to preserve the original aspect ratio. Distortion can occur, and the application may appear stretched or compressed."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"NoBorder"),": The entire application fills the specified area, without distortion but possibly with some cropping, while maintaining the original aspect ratio of the application."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"NoBorderPixelPerfect"),": Pixel perfect version of NoBorder. Scaling is limited to integer values."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"ShowAll"),": The entire application is visible in the specified area without distortion while maintaining the original aspect ratio of the application. Borders can appear on two sides of the application."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"ShowAllPixelPerfect"),": Pixel perfect version of ShowAll. Scaling is limited to integer values."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"FixedHeight"),": The application takes the height of the design resolution size and modifies the width of the internal canvas so that it fits the aspect ratio of the device. No distortion will occur, however you must make sure your application works on different aspect ratios"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"FixedHeightPixelPerfect"),": Pixel perfect version of FixedHeight. Scaling is limited to integer values."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"FixedWidth"),": The application takes the width of the design resolution size and modifies the height of the internal canvas so that it fits the aspect ratio of the device. No distortion will occur, however you must make sure your application works on different aspect ratios"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"FixedWidthPixelPerfect"),": Pixel perfect version of FixedWidth. Scaling is limited to integer values."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"BestFit"),': The application takes the width and height that best fits the design resolution with optional cropping inside of the "bleed area" and possible letter/pillar boxing. Works just like ShowAll except with horizontal/vertical bleed (padding). Gives you an area much like the old TitleSafeArea. Example: if design resolution is 1348x900 and bleed is 148x140 the safe area would be 1200x760 (design resolution - bleed).')),Object(o.b)("h2",{id:"entity"},"Entity"),Object(o.b)("p",null,"Entities are added/removed to/from the Scene and managed by it. You can either subclass Entity or just create an Entity instance and add any required Components to it (via ",Object(o.b)("strong",{parentName:"p"},"AddComponent")," and later retrieved via ",Object(o.b)("strong",{parentName:"p"},"GetComponent"),"). On their most basic level Entities can be thought of as a container for Components. Entities have a series of methods that are called by the Scene at various times throughout their lifetime."),Object(o.b)("p",null,"Entity Lifecycle methods:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnAddedToScene"),": called when the entity is added to a scene after all pending entity changes are committed"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnRemovedFromScene"),": called when the entity is removed from a scene"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Update"),": called each frame as long as the Entity is enabled"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"DebugRender"),": called if Core.debugRenderEnabled is true by the default renderers. Custom renderers can choose to call it or not. The default implementation calls debugRender on all Components and the attached Colliders if there are any")),Object(o.b)("p",null,"Some of the key/important properties on an Entity are the following:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"UpdateOrder"),": controls the order of Entities. This affects the order in which update is called on each Entity as well as the order of the tag lists."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Tag"),": use this however you want to. It can later be used to query the scene for all Entities with a specific tag (",Object(o.b)("strong",{parentName:"li"},"Scene.FindEntitiesByTag"),")."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Colliders"),":  the Colliders managed by this Entity. Adding any Colliders automatically registers the Collider with the Physics system."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"UpdateInterval"),": specifies how often this Entities update method should be called. 1 means every frame, 2 is every other, etc")),Object(o.b)("h2",{id:"component"},"Component"),Object(o.b)("p",null,"Components are added to and managed by an Entity. They make up the meat of your game and are basically reuseable chunks of code that decide how your Entities will behave. Several Component subclasses are included with Nez including text display, image display, animated sprites, Tiled maps and more."),Object(o.b)("p",null,"Component Lifecycle methods:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Initialize"),": called when the Component is created and the Entity field is assigned but before onAddedToEntity"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnAddedToEntity"),": called when the Component is added to an entity after all pending component changes are committed"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnRemovedFromEntity"),":  called when the component is removed from its entity. Do all cleanup here."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnEntityPositionChanged"),": called when the entity's position changes. This allows components to be aware that they have moved due to the parent entity moving."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Update"),": called each frame as long as the Entity and Component are enabled and the Component implements IUpdatable"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"DebugRender"),": conditionally called. See Entity section for details. It can be disabled by setting ",Object(o.b)("inlineCode",{parentName:"li"},"debugRenderEnabled")," to false for something that should be excluded from debug render"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnEnabled"),": called when the parent Entity or the Component is enabled"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"OnDisabled"),": called when the parent Entity or the Component is disabled")),Object(o.b)("p",null,"It is worth mentioning the ",Object(o.b)("inlineCode",{parentName:"p"},"RenderableComponent")," abstract Component subclass here. ",Object(o.b)("inlineCode",{parentName:"p"},"RenderableComponent")," is a special kind of component that has a ",Object(o.b)("inlineCode",{parentName:"p"},"Render")," method that is called by a Renderer. RenderableComponent handles a lot of dirtywork automatically (such as managing the bounds for culling) and includes a bunch of handy methods and properties pertaining to display. Have a look at the included RenderableComponent subclasses for examples of how they work."),Object(o.b)("h2",{id:"materials"},"Materials"),Object(o.b)("p",null,"Each ",Object(o.b)("inlineCode",{parentName:"p"},"RenderableComponent")," has an optional ",Object(o.b)("inlineCode",{parentName:"p"},"Material"),". The material lets you set per-renderable details such as the BlendState (Alpha by default), DepthStencilState (None by default), SamplerState (PointClamp by default) and Effect (null by default)."))}d.isMDXComponent=!0}}]);