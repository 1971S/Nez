(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{101:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(3),o=n(7),i=(n(0),n(109)),r={id:"NezUI",title:"Nez UI"},l={unversionedId:"features/UI/NezUI",id:"features/UI/NezUI",isDocsHomePage:!1,title:"Nez UI",description:"Nez UI is based on TableLayout (click for documentation) and the libGDX Scene2D UI system (docs are here). You can find detailed docs on the libGDX table here. As of this writing the API is nearly identical. The main differences to be aware of when using the libGDX docs for reference are:",source:"@site/docs\\features\\UI\\NezUI.md",slug:"/features/UI/NezUI",permalink:"/Nez/docs/features/UI/NezUI",editUrl:"https://github.com/prime31/Nez/edit/master/Nez.github.io/docs/features/UI/NezUI.md",version:"current",sidebar:"someSidebar",previous:{title:"Nez SVG Support",permalink:"/Nez/docs/features/Graphics/SVG"},next:{title:"Dear IMGUI",permalink:"/Nez/docs/features/UI/DearImGui"}},s=[{value:"Skins",id:"skins",children:[]},{value:"Programmatic Skin Creation",id:"programmatic-skin-creation",children:[]},{value:"Gamepad Input",id:"gamepad-input",children:[]}],d={toc:s};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Nez UI is based on TableLayout (",Object(i.b)("a",{parentName:"p",href:"https://github.com/EsotericSoftware/tablelayout/blob/master/README.md"},"click for documentation"),") and the libGDX Scene2D UI system (docs are ",Object(i.b)("a",{parentName:"p",href:"https://github.com/libgdx/libgdx/wiki/Scene2d.ui"},"here"),"). You can find detailed docs on the libGDX table ",Object(i.b)("a",{parentName:"p",href:"https://github.com/libgdx/libgdx/wiki/Table"},"here"),". As of this writing the API is nearly identical. The main differences to be aware of when using the libGDX docs for reference are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the Actor class is Element in Nez"),Object(i.b)("li",{parentName:"ul"},"the Widget and WidgetGroup classes dont exist in Nez. Similar functionality is found in the Element and Group classes but this is really only relevant if you are making your own custom controls.")),Object(i.b)("p",null,"Lets jump right in and see what its like to make a UI. We will make a UI with a ProgressBar and Slider (both horizontal) and Button centered in a vertical stack. Note that the ",Object(i.b)("inlineCode",{parentName:"p"},"Stage")," referenced below is directly from the ",Object(i.b)("inlineCode",{parentName:"p"},"UICanvas")," component, which is a simple base component for managing a Stage."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-csharp"},"// tables are very flexible and make good candidates to use at the root of your UI. They work much like HTML tables but with more flexibility.\nvar table = Stage.AddElement( new Table() );\n\n// tell the table to fill all the available space. In this case that would be the entire screen.\ntable.SetFillParent( true );\n\n// add a ProgressBar\nvar bar = new ProgressBar( 0, 1, 0.1f, false, ProgressBarStyle.Create( Color.Black, Color.White ) );\ntable.Add( bar );\n\n// this tells the table to move on to the next row\ntable.Row();\n\n// add a Slider\nvar slider = new Slider( 0, 1, 0.1f, false, SliderStyle.Create( Color.DarkGray, Color.LightYellow ) );\ntable.Add( slider );\ntable.Row();\n\n// if creating buttons with just colors (PrimitiveDrawables) it is important to explicitly set the minimum size since the colored textures created\n// are only 1x1 pixels\nvar button = new Button( ButtonStyle.Create( Color.Black, Color.DarkGray, Color.Green ) );\ntable.Add( button ).SetMinWidth( 100 ).SetMinHeight( 30 );\n")),Object(i.b)("h2",{id:"skins"},"Skins"),Object(i.b)("p",null,"Nez UI supports a skin system similar to ",Object(i.b)("a",{parentName:"p",href:"https://github.com/libgdx/libgdx/wiki/Skin"},"libGDX skins"),". Skins are optional but highly recommended. They act as a container to hold all of your UI resources and offer a bunch of automatic conversions. Nez includes a simple, default skin (accessible via ",Object(i.b)("inlineCode",{parentName:"p"},"Skin.CreateDefaultSkin"),") that you can use to mock up UIs quickly. You can create a skin programatically or via a JSON file that is run through the UI Skin Importer in the Pipeline tool. This gets the JSON parsed at build time so the data is ready to use at runtime. Below is example JSON with some comments added explaining the different elements."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-javascript"},"{\n    // defines colors accessible via skin.getColor. These can also be referenced in actual style definitions below\n    Colors:\n    {\n        green: '#00ff00',\n        orange: '#ff9900',\n        blue: '#0000ff',\n        black: [0, 0, 0, 255],\n        gray: [50, 50, 50, 255],\n        blue: [116, 139, 167, 255],\n        dialogDim: [50, 50, 50, 50]\n    },\n    // array of any LibGdxAtlases. The path should be the same one you would use to load it via the content system.\n    LibGdxAtlases: [ 'bin/skin/uiskinatlas' ],\n\n    // array of any TextureAtlases. The path should be the same one you would use to load it via the content system.\n    TextureAtlases: [ 'bin/skin/textureAtlas' ],\n\n    // the rest of the file is specific style types. The key (ButtonStyle here) is the exact class name from the UI element.\n    ButtonStyle:\n    {\n        // \"default\" is the name of the style that is used at runtime to find it. Any font, color or IDrawable can be specified.\n        // Nez UI will search any loaded atlases for the specified resource.\n        default: { Down: 'default-round-down', Up: 'default-round' },\n        toggle: { Down: 'default-round-down', Checked: 'default-round-down', Up: 'default-round' },\n        // this ButtonStyle uses only references to colors. Nez UI will handle making appropriate resources at runtime for you.\n        colored: { Down: 'gray', Up: 'black', Over: 'blue' }\n    },\n    SplitPaneStyle:\n    {\n        'default-vertical': { Handle: 'default-splitpane-vertical' },\n        'default-horizontal': { Handle: 'default-splitpane' }\n    },\n    WindowStyle:\n    {\n        // the titleFontColor directly references a color that we specified above in the colors section\n        default: { TitleFont: 'nez/NezDefaultBMFont', Background: 'default-window', TitleFontColor: 'white' },\n        dialog: { TitleFont: 'nez/NezDefaultBMFont', Background: 'default-window', TitleFontColor: 'white', StageBackground: 'dialogDim' }\n    },\n    ProgressBarStyle:\n    {\n        'default-horizontal': { Background: 'default-slider', Knob: 'default-slider-knob' },\n        'default-vertical': { Background: 'default-slider', Knob: 'default-round-large' }\n    },\n    SliderStyle:\n    {\n        'default-horizontal': { Background: 'default-slider', Knob: 'default-slider-knob' },\n        'default-vertical': { Background: 'default-slider', Knob: 'default-round-large' }\n    },\n    LabelStyle:\n    {\n        // fonts should be the same path you would use to load it via the content system\n        default: { Font: 'nez/NezDefaultBMFont', FontColor: 'white' },\n        tooltip: { Font: 'nez/NezDefaultBMFont', FontColor: 'blue' },\n    },\n    TextTooltipStyle:\n    {\n        // note that LabelStyle referes the the 'tooltip' LabelStyle defined above\n        default: { LabelStyle: 'tooltip', Background: 'gray' }\n    }\n}\n")),Object(i.b)("p",null,"Now that we have the skin lets create a few elements with it."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-csharp"},'var skin = new Skin( "skins/uiskinconfig", Core.Content );\n\n// notice that we can directly fetch the style for the button via the name we specified in the JSON\nvar button = new Button( skin.Get<TextButtonStyle>( "default" ) );\n// alternatively, we could create the button like this. Note that we are just giving it the skin so as long as there is\n// a style named "default" that is what will be used.\nvar button = new Button( skin );\n\nvar bar = new ProgressBar( 0, 1, 0.1f, vertical, skin.Get<ProgressBarStyle>( "default-vertical" ) );\n\n// this button uses the \'colored\' style that we made using only colors. We have to remember to give it\n// some girth since it isnt an image and has no height/width.\nvar button = new Button( skin.Get<ButtonStyle>( "colored" ) );\ntable.Add( button ).SetMinWidth( 100 ).SetMinHeight( 30 );\n')),Object(i.b)("h2",{id:"programmatic-skin-creation"},"Programmatic Skin Creation"),Object(i.b)("p",null,"You do not have to use the JSON config file and pipeline importer to get the benefits of using a skin. Skins can also be created programmatically though it can be a bit tedious. Luckily, once you have code to make your skin using it is simple!"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-csharp"},'// create the Skin\nvar skin = new Skin();\n\n// add a texture atlas so we have some images to work with\nskin.AddSprites( Content.Load<LibGdxAtlas>( "skins/UIAtlas" ) );\n\n// add a bunch of styles for our elements. Note that the getDrawable method is very flexible. The name passed to it can be any type of\n// IDrawable or it can be a Sprite, NinePatchSprite or Color. In the latter case Skin will create and manage the IDrawable\n// for you automatically.\nskin.Add( "button", new ButtonStyle( skin.GetDrawable( "default-round" ), skin.GetDrawable( "default-round-down" ), null ) );\n\n// add a toggle button. It needs a checked image to trigger this being a two state button.\nskin.Add( "toggle-button", new ButtonStyle( skin.GetDrawable( "default-round-down" ), skin.GetDrawable( "default-round-down" ), null )\n{\n    Checked = skin.getDrawable( "default-round" )\n});\n\nskin.Add( "text-button", new TextButtonStyle {\n    Down = skin.getDrawable( "default-round-down" ),\n    Up = skin.getDrawable( "default-round" ),\n    FontColor = Color.White\n} );\n\nskin.Add( "progressbar-h", new ProgressBarStyle( skin.GetDrawable( "default-slider" ), skin.GetDrawable( "default-slider-knob" ) ) );\n\nskin.Add( "slider-h", new SliderStyle( skin.GetDrawable( "default-slider" ), skin.GetDrawable( "default-slider-knob" ) ) );\n\n// a CheckBox differs from the toggle-button above in that it contains text next to the box\nskin.Add( "checkbox", new CheckBoxStyle( skin.GetDrawable( "check-off" ), skin.GetDrawable( "check-on" ), null, Color.White ) );\n\nskin.Add( "textfield", new TextFieldStyle( null, Color.White, skin.GetDrawable( "cursor" ), skin.GetDrawable( "selection" ), skin.GetDrawable( "textfield" ) )\n')),Object(i.b)("h2",{id:"gamepad-input"},"Gamepad Input"),Object(i.b)("p",null,"Nez UI supports gamepad input out of the box via the ",Object(i.b)("inlineCode",{parentName:"p"},"IGamepadFocusable")," interface. Buttons (and any subclasses such as TextButton, Checkbox, etc) and Sliders will work out of the box (note that Sliders require ",Object(i.b)("inlineCode",{parentName:"p"},"ShouldUseExplicitFocusableControl")," to be true). To enable gamepad input processing just set the first focusable element via the ",Object(i.b)("inlineCode",{parentName:"p"},"stage.SetGamepadFocusElement")," method. That will trigger the stage to use gamepad input. By default, the A button will be used for activating a UI Element. You can change this via the ",Object(i.b)("inlineCode",{parentName:"p"},"stage.GamepadActionButton"),". Also by default keyboard input (arrow keys and enter) will also work and is customizable via ",Object(i.b)("inlineCode",{parentName:"p"},"KeyboardEmulatesGamepad")," and ",Object(i.b)("inlineCode",{parentName:"p"},"KeyboardActionKey"),". If you have custom controls that would like to take part in gamepad input just implement the IGamepadFocusable interface on the element. If you are subclassing Button or Slider it is even easier: just override any of the 4 focus handlers: ",Object(i.b)("inlineCode",{parentName:"p"},"UnFocused"),", ",Object(i.b)("inlineCode",{parentName:"p"},"UnUnfocused"),", ",Object(i.b)("inlineCode",{parentName:"p"},"UnActionButtonPressed")," and ",Object(i.b)("inlineCode",{parentName:"p"},"UnActionButtonReleased"),"."),Object(i.b)("p",null,"If you want finer grained control over which Element gains focus when a particular direction is pressed on the gamepad you can manually set the ",Object(i.b)("inlineCode",{parentName:"p"},"GamepadUp/Down/Left/RightElement")," properties. Leaving any null will result in no focus change when that direction is pressed and the ",Object(i.b)("inlineCode",{parentName:"p"},"UnUnhandledDirectionPressed")," method will be called. Note that you must also set ",Object(i.b)("inlineCode",{parentName:"p"},"IGamepadFocusable.ShouldUseExplicitFocusableControl")," when setting these directly. Below is a simple example of setting up 2 buttons and a slider horizontally. The slider's value will be changed when up/down is pressed on the gamepad."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-csharp"},"// create buttons and a slider...\n\n// be sure to enable explicit control on each Element!\nleftButton.ShouldUseExplicitFocusableControl = true;\n// when pressing right change control to the middleSlider\nleftButton.GamepadRightElement = middleSlider;\n// optional. This would make pressing left wrap around to the rightButton\nleftButton.GamepadLeftElement = rightButton;\n\nmiddleSlider.ShouldUseExplicitFocusableControl = true;\nmiddleSlider.GamepadLeftElement = leftButton;\nmiddleSlider.GamepadRightElement = rightButton;\n\nrightButton.ShouldUseExplicitFocusableControl = true;\nrightButton.GamepadLeftElement = middleSlider;\n// optional. This would make pressing right wrap around to the leftButton\nrightButton.GamepadRightElement = leftButton;\n\n")))}u.isMDXComponent=!0},109:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return p}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=o.a.createContext({}),u=function(e){var t=o.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return o.a.createElement(d.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(n),h=a,p=c["".concat(r,".").concat(h)]||c[h]||b[h]||i;return n?o.a.createElement(p,l(l({ref:t},d),{},{components:n})):o.a.createElement(p,l({ref:t},d))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);